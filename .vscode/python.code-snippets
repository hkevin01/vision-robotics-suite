{
  "Python OPC UA Client": {
    "scope": "python",
    "prefix": "opcua-client",
    "body": [
      "from opcua import Client",
      "",
      "class OPCUAClient:",
      "    def __init__(self, endpoint_url: str):",
      "        self.client = Client(endpoint_url)",
      "        self.connected = False",
      "    ",
      "    def connect(self):",
      "        try:",
      "            self.client.connect()",
      "            self.connected = True",
      "            print(f\"Connected to OPC UA server\")",
      "        except Exception as e:",
      "            print(f\"Connection failed: {e}\")",
      "    ",
      "    def disconnect(self):",
      "        if self.connected:",
      "            self.client.disconnect()",
      "            self.connected = False",
      "            print(\"Disconnected from OPC UA server\")",
      "    ",
      "    def read_node(self, node_id: str):",
      "        if not self.connected:",
      "            raise ConnectionError(\"Not connected to server\")",
      "        node = self.client.get_node(node_id)",
      "        return node.get_value()",
      "    ",
      "    def write_node(self, node_id: str, value):",
      "        if not self.connected:",
      "            raise ConnectionError(\"Not connected to server\")",
      "        node = self.client.get_node(node_id)",
      "        node.set_value(value)",
      "",
      "# Usage",
      "client = OPCUAClient(\"opc.tcp://localhost:4840\")",
      "client.connect()",
      "$0"
    ],
    "description": "Create OPC UA client connection template"
  },

  "Robot Controller Base Class": {
    "scope": "python",
    "prefix": "robot-controller",
    "body": [
      "from abc import ABC, abstractmethod",
      "from typing import List, Tuple, Optional",
      "import logging",
      "",
      "class RobotController(ABC):",
      "    \"\"\"Base class for robot controllers\"\"\"",
      "    ",
      "    def __init__(self, ip_address: str, port: int = 80):",
      "        self.ip_address = ip_address",
      "        self.port = port",
      "        self.connected = False",
      "        self.logger = logging.getLogger(self.__class__.__name__)",
      "    ",
      "    @abstractmethod",
      "    def connect(self) -> bool:",
      "        \"\"\"Connect to robot controller\"\"\"",
      "        pass",
      "    ",
      "    @abstractmethod",
      "    def disconnect(self) -> bool:",
      "        \"\"\"Disconnect from robot controller\"\"\"",
      "        pass",
      "    ",
      "    @abstractmethod",
      "    def move_to_position(self, x: float, y: float, z: float, ",
      "                        rx: float = 0, ry: float = 0, rz: float = 0) -> bool:",
      "        \"\"\"Move robot to specified position\"\"\"",
      "        pass",
      "    ",
      "    @abstractmethod",
      "    def get_current_position(self) -> Tuple[float, float, float, float, float, float]:",
      "        \"\"\"Get current robot position\"\"\"",
      "        pass",
      "    ",
      "    @abstractmethod",
      "    def execute_program(self, program_name: str) -> bool:",
      "        \"\"\"Execute robot program\"\"\"",
      "        pass",
      "    ",
      "    def is_connected(self) -> bool:",
      "        return self.connected",
      "",
      "$0"
    ],
    "description": "Base robot controller class template"
  },

  "Vision System Template": {
    "scope": "python",
    "prefix": "vision-system",
    "body": [
      "import cv2",
      "import numpy as np",
      "from typing import List, Tuple, Optional",
      "",
      "class VisionSystem:",
      "    \"\"\"Vision processing system for industrial automation\"\"\"",
      "    ",
      "    def __init__(self, camera_id: int = 0):",
      "        self.camera_id = camera_id",
      "        self.camera = None",
      "        self.calibration_matrix = None",
      "        self.distortion_coeffs = None",
      "    ",
      "    def initialize_camera(self) -> bool:",
      "        \"\"\"Initialize camera connection\"\"\"",
      "        try:",
      "            self.camera = cv2.VideoCapture(self.camera_id)",
      "            if not self.camera.isOpened():",
      "                return False",
      "            return True",
      "        except Exception as e:",
      "            print(f\"Camera initialization failed: {e}\")",
      "            return False",
      "    ",
      "    def capture_image(self) -> Optional[np.ndarray]:",
      "        \"\"\"Capture single image from camera\"\"\"",
      "        if self.camera is None:",
      "            return None",
      "        ret, frame = self.camera.read()",
      "        return frame if ret else None",
      "    ",
      "    def detect_objects(self, image: np.ndarray) -> List[dict]:",
      "        \"\"\"Detect objects in image\"\"\"",
      "        # Convert to grayscale",
      "        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)",
      "        ",
      "        # Apply thresholding",
      "        _, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)",
      "        ",
      "        # Find contours",
      "        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)",
      "        ",
      "        objects = []",
      "        for contour in contours:",
      "            # Calculate bounding rectangle",
      "            x, y, w, h = cv2.boundingRect(contour)",
      "            area = cv2.contourArea(contour)",
      "            ",
      "            if area > 100:  # Filter small objects",
      "                objects.append({",
      "                    'x': x + w//2,",
      "                    'y': y + h//2,",
      "                    'width': w,",
      "                    'height': h,",
      "                    'area': area",
      "                })",
      "        ",
      "        return objects",
      "    ",
      "    def release(self):",
      "        \"\"\"Release camera resources\"\"\"",
      "        if self.camera:",
      "            self.camera.release()",
      "",
      "$0"
    ],
    "description": "Vision system template for object detection"
  },

  "PLC Communication": {
    "scope": "python",
    "prefix": "plc-comm",
    "body": [
      "import socket",
      "import struct",
      "from typing import Any, Optional",
      "",
      "class PLCCommunication:",
      "    \"\"\"Basic PLC communication interface\"\"\"",
      "    ",
      "    def __init__(self, ip_address: str, port: int = 502):",
      "        self.ip_address = ip_address",
      "        self.port = port",
      "        self.socket = None",
      "        self.connected = False",
      "    ",
      "    def connect(self) -> bool:",
      "        \"\"\"Connect to PLC\"\"\"",
      "        try:",
      "            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
      "            self.socket.connect((self.ip_address, self.port))",
      "            self.connected = True",
      "            return True",
      "        except Exception as e:",
      "            print(f\"PLC connection failed: {e}\")",
      "            return False",
      "    ",
      "    def disconnect(self):",
      "        \"\"\"Disconnect from PLC\"\"\"",
      "        if self.socket:",
      "            self.socket.close()",
      "            self.connected = False",
      "    ",
      "    def read_register(self, address: int) -> Optional[int]:",
      "        \"\"\"Read register from PLC\"\"\"",
      "        if not self.connected:",
      "            return None",
      "        # Implementation depends on PLC protocol",
      "        # This is a template - actual implementation varies",
      "        pass",
      "    ",
      "    def write_register(self, address: int, value: int) -> bool:",
      "        \"\"\"Write register to PLC\"\"\"",
      "        if not self.connected:",
      "            return False",
      "        # Implementation depends on PLC protocol",
      "        # This is a template - actual implementation varies",
      "        pass",
      "    ",
      "    def read_coil(self, address: int) -> Optional[bool]:",
      "        \"\"\"Read coil (digital output) from PLC\"\"\"",
      "        if not self.connected:",
      "            return None",
      "        # Implementation depends on PLC protocol",
      "        pass",
      "    ",
      "    def write_coil(self, address: int, value: bool) -> bool:",
      "        \"\"\"Write coil (digital output) to PLC\"\"\"",
      "        if not self.connected:",
      "            return False",
      "        # Implementation depends on PLC protocol",
      "        pass",
      "",
      "$0"
    ],
    "description": "PLC communication template"
  },

  "Quality Control Check": {
    "scope": "python",
    "prefix": "quality-check",
    "body": [
      "from dataclasses import dataclass",
      "from typing import List, Optional",
      "from datetime import datetime",
      "import statistics",
      "",
      "@dataclass",
      "class QualityMeasurement:",
      "    \"\"\"Single quality measurement\"\"\"",
      "    parameter_name: str",
      "    measured_value: float",
      "    target_value: float",
      "    tolerance_upper: float",
      "    tolerance_lower: float",
      "    timestamp: datetime",
      "    ",
      "    @property",
      "    def is_within_tolerance(self) -> bool:",
      "        return self.tolerance_lower <= self.measured_value <= self.tolerance_upper",
      "    ",
      "    @property",
      "    def deviation(self) -> float:",
      "        return self.measured_value - self.target_value",
      "",
      "class QualityController:",
      "    \"\"\"Quality control system for manufacturing\"\"\"",
      "    ",
      "    def __init__(self):",
      "        self.measurements: List[QualityMeasurement] = []",
      "    ",
      "    def add_measurement(self, measurement: QualityMeasurement):",
      "        \"\"\"Add new quality measurement\"\"\"",
      "        self.measurements.append(measurement)",
      "    ",
      "    def check_part_quality(self, measurements: List[QualityMeasurement]) -> bool:",
      "        \"\"\"Check if part meets quality requirements\"\"\"",
      "        return all(m.is_within_tolerance for m in measurements)",
      "    ",
      "    def calculate_cpk(self, parameter_name: str, window_size: int = 30) -> Optional[float]:",
      "        \"\"\"Calculate process capability index Cpk\"\"\"",
      "        recent_measurements = [",
      "            m for m in self.measurements[-window_size:]",
      "            if m.parameter_name == parameter_name",
      "        ]",
      "        ",
      "        if len(recent_measurements) < 10:",
      "            return None",
      "        ",
      "        values = [m.measured_value for m in recent_measurements]",
      "        mean_value = statistics.mean(values)",
      "        std_dev = statistics.stdev(values)",
      "        ",
      "        if std_dev == 0:",
      "            return float('inf')",
      "        ",
      "        # Get specification limits from first measurement",
      "        spec = recent_measurements[0]",
      "        usl = spec.tolerance_upper",
      "        lsl = spec.tolerance_lower",
      "        ",
      "        cpu = (usl - mean_value) / (3 * std_dev)",
      "        cpl = (mean_value - lsl) / (3 * std_dev)",
      "        ",
      "        return min(cpu, cpl)",
      "    ",
      "    def generate_report(self) -> dict:",
      "        \"\"\"Generate quality control report\"\"\"",
      "        if not self.measurements:",
      "            return {}",
      "        ",
      "        total_parts = len(set(m.timestamp for m in self.measurements))",
      "        passed_measurements = sum(1 for m in self.measurements if m.is_within_tolerance)",
      "        yield_rate = (passed_measurements / len(self.measurements)) * 100",
      "        ",
      "        return {",
      "            'total_parts_inspected': total_parts,",
      "            'total_measurements': len(self.measurements),",
      "            'yield_rate_percent': yield_rate,",
      "            'last_inspection': max(m.timestamp for m in self.measurements)",
      "        }",
      "",
      "$0"
    ],
    "description": "Quality control system template"
  }
}
